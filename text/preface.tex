\chapwithtoc{Introduction}

Despite a slow decline in recent years \citep{Tiobe}, PHP is still one of the main languages used for a server side programming on the web \citep{Stack}. Its only two relevant implementations are the reference and almost exclusively used Zend engine\footnote{\href{http://www.zend.com/en/community/php}{zend.com/en/community/php}} and slowly emerging HHVM by Facebook\footnote{\href{http://hhvm.com/}{hhvm.com/}}. Both of them are standalone virtual machines and neither of them supports easy interfacing with the outside world. Hence, it is quite difficult to share code between a web backend and, for example, a~mobile or traditional desktop application.

Fortunately, there is a solution in the form of a Peachpie project\footnote{\href{http://www.peachpie.io/}{peachpie.io/}} that is being researched at the Charles University. The project aims to provide a compiler from PHP to “.NET bytecode” CIL\footnote{Chapter \ref{CIL}} and a reimplementation of PHP base class library, thus creating a bridge between PHP and the whole .NET ecosystem. Due to it being a full compiler that takes PHP sources and spits out .NET assemblies indistinguishable from those created by other .NET languages compilers (e.g C\#, F\# or IronPython) it provides both ways interoperability. It enables both calling normal unmodified .NET libraries from PHP and vice versa. Also, thanks to an extensive compile-time type analysis and proven .NET just in time compiler (RiuJIT) it achieves better performance than reference Zend engine in certain operations \citep{PchpBenchBlog}, \citep{PchpBenchSite}.

PHP, like many other modern languages, has a first class support for generators. Simply put, generators are methods that resume computation from the very place and with the same state they returned at previously when called repeatedly. They are usually used for generating large sequences of data lazily, hence the name generators. Since the execution state gets saved automatically on the special pause and return places (usually called yields) one can write an algorithm as if the sequence was being created at once and only insert yields at appropriate times, e.g. when a new item gets created. The language handles the rest. Each subsequent call to the generator method resumes computation from the last evaluated yield and continues to the next one, e.g. creating a new element each time. 

The Zend engine has a native support for generators. It intrinsically understands yields and is, on their evaluation, able to save the state of current execution \citep{ZendGen}. CIL has no such first class support. For that reason languages built on top of CIL have to implement generators through other means \citep{CSharpGen}. Usually by rewriting generator methods into state machines with explicit state saving before each yield and state retrieval in the beginning.

That is exactly what this thesis covers. It describes the design and implementation of support for PHP generators within the Peachpie compiler through semantic tree transformations, implementation of new semantic tree nodes, and extensions to Peachpie runtime library. In the implementation parts it tries to not only plainly cover the code but also to depict the decision process that led to choosing certain approaches over others. During the whole work we will compare our approach with the one taken by C\# team and its compiler Roslyn. C\# was chosen as a reference language due to it being the prominent language in .NET platform.

While the goal is to implement support for generators with as much original PHP semantic as possible, due to the scope of this work we will not discuss the specific implementation of all PHP generators features. Namely, we will not cover handling yields in exception control blocks (try, catch, finally) in detail and will leave its implementation for future work.

\secwithtoc{Thesis structure}
This thesis is divided into seven chapters. The first one covers general concepts of generators both in PHP and in other languages, explaining what they are, what features and limitations do they have, and where they stand in regards to iterators. 

The second chapter briefly introduces the .NET platform and its intermediate language CIL. The third is all about the Peachpie project. It describes its architecture focusing mainly on the semantic tree data structure and CIL emit phase of the compiler. In fourth chapter we take a look at how generators are implemented in C\#’s Roslyn and PHP’s Zend engine. Especially the Roslyn’s approach is important because it serves as a basis for our own implementation.
 
Generators within Peachpie is the focus of the fifth chapter which itself is further divided into five more sections. First describes an implementation of generators limited to circa C\# generators. It builds on the theoretical basis described in previous section about Roslyn’s approach. Second proposes theoretical algorithm to handle yield as expression. Third talks about implementation of said algorithm within peachpie. Fourth briefly mentions possible solutions for yields in exception handling blocks. And the fifth is about possible future work that could be done for generators support within peachpie. 

The sixth chapter concludes and summarizes the whole thesis. And last but not least the final chapter provides a lightweight user documentation for the peachpie project and overview of attachments.
