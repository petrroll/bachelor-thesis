\chapwithtoc{Introduction}

Despite a slight  decline in recent years \citep{Tiobe}, PHP is still one of the main languages used for server side programming on the web \citep{Stack}. Its only two relevant implementations are the reference and almost exclusively used Zend engine\footnote{\href{http://www.zend.com/en/community/php}{zend.com/en/community/php}} and the slowly emerging HHVM by Facebook\footnote{\href{http://hhvm.com/}{hhvm.com/}}. Both of them are standalone virtual machines and neither of them supports easy interfacing with the outside world. Hence, it is quite difficult to share code between a web backend and, for example, a~mobile or traditional desktop application.

Fortunately, there is a solution in the form of the Peachpie project\footnote{\href{http://www.peachpie.io/}{peachpie.io/}} that is being researched at the Charles University. The project aims to provide a compiler from PHP to “.NET bytecode” CIL\footnote{Chapter \ref{CIL}} and a reimplementation of the PHP base class library, thus creating a bridge between PHP and the whole .NET ecosystem. Due to the fact that it is a full compiler that takes PHP sources and outputs .NET assemblies indistinguishable from those created by other .NET languages compilers (e.g C\#, F\# or IronPython), it provides a both-way interoperability. It enables both calling normal unmodified .NET libraries from PHP and vice versa. Also, thanks to an extensive compile-time type analysis and the proven .NET just in time compiler (RiuJIT) it achieves better performance than the reference Zend engine in certain operations \citep{PchpBenchBlog, PchpBenchSite}.

PHP, like many other modern languages, has a first class support for generators. In short, generators are methods that, when called repeatedly, resume the computation from the very place and with the same state they returned at previously. They are usually used for generating large sequences of data lazily, hence the name generators. Since the execution state gets saved automatically on the special pause and return places (usually called yields), one can write an algorithm as if the sequence were being created at once and only insert yields at appropriate times, e.g. when a new item gets created. The language handles the rest. Each subsequent call to the generator method resumes the computation from the last evaluated yield and continues to the next one, e.g. creating a new element each time. 

The Zend engine has a native support for generators. It intrinsically understands yields and is, on their evaluation, able to save the state of current execution \citep{ZendGen}. CIL has no such first class support. For that reason, languages built on top of the CIL have to implement generators through other means \citep{CSharpGen} - usually by rewriting generator methods into state machines with the explicit state saving before each yield and a state retrieval in the beginning.

This thesis describes the design and implementation of a support for PHP generators within the Peachpie compiler through semantic tree transformations, an implementation of new semantic tree nodes, and extensions to the Peachpie runtime library. In the implementation parts, the thesis not only tries to plainly cover the code, but also to depict the decision process that led to choosing certain approaches over others. Throughout the work, we will compare our approach with the one taken by the C\# team and its compiler Roslyn. C\# was chosen as a reference language due to  being the prominent language in .NET platform.

While the goal is to implement a support for generators with as much original PHP semantic as possible, due to the scope of this work we will not discuss the specific implementation of all PHP generator features. Namely, we will not cover handling yields in exception control blocks (try, catch, finally) in detail and will leave its implementation for future work.

\secwithtoc{Thesis structure}
This thesis is divided into seven chapters. The first one covers general concepts of generators both in PHP and in other languages, explaining what they are, what features and limitations they have, and where they stand with regards to iterators. 

The second chapter briefly introduces the .NET platform and its intermediate language CIL. The third is entirely about the Peachpie project. It describes its architecture, focusing mainly on the semantic tree data structure and CIL emit phase of the compiler. In the fourth chapter, we examine how generators are implemented in C\#’s Roslyn and PHP’s Zend engine. Roslyn’s approach is particularly important, because it serves as a basis for our own implementation.
 
Generators within Peachpie is the focus of the fifth chapter, which itself is further divided into five subsections. The first part describes an implementation of generators limited to circa C\# generators. It builds on the theoretical basis described in the previous section about Roslyn’s approach. The second one proposes a theoretical algorithm to handle yield as an expression. The third subsection discusses the implementation of said algorithm within Peachpie. In the fourth part, we briefly mention the possible solutions for yields in exception handling blocks. Finally, the fifth subsection is about possible future work that could be done for generator support within Peachpie. 

The sixth chapter concludes and summarizes the whole thesis. Ultimately, the final chapter provides a lightweight user documentation for the Peachpie project and an overview of attachments.
